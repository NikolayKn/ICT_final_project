"""
Successive cancellation list decoding with CRC-aided list selection.
"""
from enum import Enum

import os
import ctypes
import galois
import numpy as np


class ListSelection(Enum):
    """
    Polar decoder supports the following list selection methods:
    - CRC: elect a codeword that corresponds to the correct CRC.
    If there are more than one candidate, use path metric to choose the best candidate
    - GENIE: select a transmitted codeword if it is present in the decoder output
    - PATH_METRIC: Select a codeword that corresponds to the best path metric
    """
    CRC = 1
    GENIE = 2
    PATH_METRIC = 3


class Polar:
    """
    This class implements polar decoding routines:
    - run successive cancellation list decoding (implemented in C++)
    - apply list selection routines
    - Decoder output: an information word estimate or empty (if no suitable candidates found)
    """
    def __init__(self, **kwargs):
        """
        There are the following groups of parameters:

        1. Specifying a code length and rate.
        One can do this by explicitly providing a frozen bit vector or
        by specifying block length ('n') and the number of information bits ('k').
        For the latter case, the frozen bits vector is generated by polarization weight metric
        Frozen bits f==0 correspond to information bits, f==1 correspond to frozen bits

        2. The list selection method: by CRC, by path metric or 'genie'
        If the frozen bit pattern is provided explicitly, the number of information bits
        will be reduced by the CRC length. If parameter 'k' is passed, the total number
        of unfrozen bits will be 'k' + the CRC size

        Remaining mandatory parameters are 1) Decoder list size and 2) whether a systematic code
        :param kwargs: User-defined parameters.
        """
        #lib_compile()
        crc_poly = []
        self.list_selection = Polar.parse_list_selection(**kwargs)
        if self.list_selection is ListSelection.CRC:
            crc_poly = np.array(Polar.get_parameter('crc_polynomial', kwargs))

        self.use_systematic = Polar.get_parameter('use_systematic', kwargs)
        self.list_size = Polar.get_parameter('list_size', kwargs)

        self.frozen = Polar.init_frozen_bit_pattern(crc_poly, **kwargs)
        self.matrices = Matrices(self.frozen, crc_poly, self.use_systematic)
        self.lib = load_shared_object()

    @staticmethod
    def get_parameter(name, kwargs):
        """
        Get parameter from the user-defined parameter list. Raise runtime error if not present
        :param name: parameter name
        :param kwargs: user-defined parameters
        :return: parameter value
        """
        if name not in kwargs.keys():
            raise RuntimeError(f'Please specify parameter {name}')
        return kwargs[name]

    @staticmethod
    def parse_list_selection(**kwargs):
        """
        Parse list selection method from user-defined parameters and raise errors if needed
        :param kwargs: user-defined parameters
        :return: ListSelection enum
        """
        if kwargs['list_selection'] == 'CRC':
            return ListSelection.CRC
        if kwargs['list_selection'] == 'genie':
            return ListSelection.GENIE
        if kwargs['list_selection'] == 'path_metric':
            return ListSelection.PATH_METRIC
        raise RuntimeError('Unknown list selection method')

    @staticmethod
    def init_frozen_bit_pattern(crc_poly, **kwargs):
        """
        Initialize information bit patter in accordance with the user-defined data.
        Total number of information bits:
        - equals to the number of zero positions if no CRC required
        - is less (by the CRC size) otherwise
        :param crc_poly: CRC polynomial
        :param kwargs: user-defined parameters
        :return: Frozen bit pattern (1 x N vector, 1 -- frozen, 0 -- information)
        """
        if 'frozen' in kwargs:
            # Specify the polar code by frozen bits
            return np.array(kwargs['frozen'])
        # Specify polar code by length and information bits count
        inf_bits_count = Polar.get_parameter('k', kwargs)
        block_len = Polar.get_parameter('n', kwargs)
        if len(crc_poly):
            inf_bits_count += len(crc_poly) - 1
        return Polar.polarization_weight_frozen(block_len, inf_bits_count)

    def encode(self, iwd):
        """
        Perform encoding by multiplying by generator matrix
        :param iwd: the information word. Check the information bit count by
        Polar.information_bits()
        :return: codeword as [0, 1] numpy array
        """
        return np.mod(np.dot(iwd, self.matrices.generator), 2).astype(np.uint8)

    def information_bits(self):
        """
        :return: a proper information bits count
        """
        return self.matrices.generator.shape[0]

    def decode(self, llr_in, **kwargs):
        """
        Perform decoding given input LLRs (llr_in).
        Note that the transmitted codeword (iwd) is required by GENIE list selection method only
        :param llr_in: Input LLR vector (of size 1xn)
        :param kwargs: Additional parameters.
        If GENIE list selection is selected, 'iwd' parameter must be passed
        :return
          1. Best suitable information word or empty np.array([]) if there are no candidates
          2. Decoded bits (for debug purpose)
        """
        decoded_bits = decode(self.lib, self.frozen, llr_in, self.list_size)
        if self.use_systematic:
            decoded_bits = np.mod(np.dot(decoded_bits, self.matrices.polar_transform), 2)
        iwd_hat_list = decoded_bits[:, self.frozen == 0]

        if self.list_selection == ListSelection.CRC:
            # CRC: return the zero CRC check information word with the best path metric.
            # The last condition is applied only if more than one candidate exists
            iwd_hat = self.select_crc(iwd_hat_list)
        elif self.list_selection == ListSelection.GENIE:
            # Genie: return an information word that matches a transmitted one
            iwd_hat = Polar.select_genie(iwd_hat_list, kwargs['iwd'])
        elif self.list_selection == ListSelection.PATH_METRIC:
            # Select by path metric: just reduce the first information word from the list
            iwd_hat = iwd_hat_list[0, :]
        else:
            raise NotImplementedError('Unknown list selection method')
        return iwd_hat, decoded_bits.T

    def select_crc(self, iwd_hat_list):
        """
        Select from the list using CRC
        :param iwd_hat_list: information word list from the decoder,
        size = (list size X (k + CRC))
        :return: Best suitable information word or empty np.array([]) if there are no candidates
        """
        crc_ok = self.crc_check(iwd_hat_list)
        iwd_hat_list = iwd_hat_list[crc_ok, :self.information_bits()]
        if iwd_hat_list.shape[0]:
            return iwd_hat_list[0, :self.information_bits()]
        return np.array([])

    def crc_check(self, iwd_hat_list):
        """
        Check whether the CRC is correct
        :param iwd_hat_list: input information word list of size (list size X (k + CRC))
        :return: mask vector (of length = list_size) with 'True' corresponding to correct CRC
        """
        syndrome = np.mod(np.dot(self.matrices.check_crc, np.transpose(iwd_hat_list)), 2)
        return np.sum(syndrome, axis=0) == 0

    @staticmethod
    def select_genie(iwd_hat_list, iwd):
        """

        :param iwd_hat_list: information words from the decoder
        :param iwd: Transmitted information word
        :return: true information word if its is present in the decoder's output
        """
        hamming_dist = np.sum(iwd_hat_list != iwd, axis=1)
        if np.min(hamming_dist) > 0:
            return np.array([])
        return iwd_hat_list[hamming_dist == 0, :][0]

    @staticmethod
    def polarization_weight_frozen(block_len, inf_bits_count):
        """
        Generate frozen bit pattern in accordance with polarization weight
        :param block_len: code length
        :param inf_bits_count: the number of information bits
        :return: frozen bits vector (f == 0 -- information bit, f == 1 -- frozen bit)
        """
        block_len_log = np.round(np.log2(block_len)).astype(np.int8)
        assert block_len == 2 ** block_len_log
        frozen = np.ones(block_len, )
        metric = np.sum(
            de2bi(np.arange(block_len), block_len_log) * np.power(2, np.arange(block_len_log) / 4),
            axis=1
        )
        # Sort metric in descending order
        frozen[np.argsort(-metric)[:inf_bits_count]] = 0
        return frozen.astype(np.uint8)


class Matrices:
    """
    This class implements polar code matrices required for encoding and decoding:
    - CRC parity check matrix (if crc is specified)
    - Systematic generator matrix (if systematic code is used)
    - Polar transform matrix (Arikan's kernel Kronecker power). This matrix transforms decoded bits
    if systematic code is used
    We use a code generator matrix as a product of CRC generator matrix
    and a polar code generator matrix (systematic or not)
    """
    def __init__(self, frozen_bits_pattern, crc_polynomial, use_systematic):
        """
        Initialize all required matrices.
        """
        inf_bits = np.sum(frozen_bits_pattern == 0)

        # Create the CRC generator and parity check matrix:
        if len(crc_polynomial):
            inf_bits -= len(crc_polynomial) - 1
            generator_crc, self.check_crc = Matrices.crc_matrices(inf_bits, crc_polynomial)
        else:
            generator_crc = np.eye(inf_bits)

        # The total generator matrix is a product of CRC generator matrix and polar generator matrix
        if use_systematic:
            self.generator = np.mod(np.dot(
                generator_crc,
                Matrices.get_generator_systematic(frozen_bits_pattern)
            ), 2)
        else:
            self.generator = np.mod(np.dot(
                generator_crc,
                Matrices.get_generator(frozen_bits_pattern)
            ), 2)

        block_len_log = np.round(np.log2(len(frozen_bits_pattern))).astype(np.int8)
        self.polar_transform = Matrices.get_polar_transform(block_len_log)

    @staticmethod
    def crc_matrices(k, crc_poly):
        """
        Create the CRC generator (crc_gm) and the parity check (crc_pcm) matrices
        given the number of information bits (k) and the CRC polynomial (as binary np.array)
        """
        n_crc = len(crc_poly) - 1
        crc_gm = np.zeros((k, k + n_crc))
        iwd = np.eye(k)
        crc_gm[:, 0:k] = iwd
        for i in range(k):
            crc_gm[i, :] = Matrices.crc_encode(iwd[i, :], crc_poly)

        crc_pcm = np.hstack([np.transpose(crc_gm[:, k:]), np.eye(n_crc)])
        assert(np.sum(np.mod(np.dot(crc_gm, np.transpose(crc_pcm)), 2)) == 0)
        return crc_gm, crc_pcm

    @staticmethod
    def crc_encode(bit_seq, crc_poly):
        """
        Encode the bit sequence with CRC
        :param bit_seq: binary np.array
        :param crc_poly: CRC polynomial
        :return: encoded binary sequence
        """
        n_crc = len(crc_poly) - 1
        x_ext = np.hstack([bit_seq, np.array([0] * n_crc)])
        res = np.copy(x_ext)
        for i in range(len(bit_seq)):
            if res[i] == 0:
                continue
            res[i:(i + len(crc_poly))] = np.mod(res[i:(i + len(crc_poly))] + crc_poly, 2)
        return np.mod(res + x_ext, 2)

    @staticmethod
    def arikan_kernel():
        """
        Binary Arikan kernel
        :return: 2x2 np.array
        """
        return np.array([[1, 0], [1, 1]])

    @staticmethod
    def get_polar_transform(block_len_log):
        """
        Create polar transform matrix
        :param block_len_log: log2() of the block length
        :return: NxN polar transform matrix, N - blocklength
        """
        kernel = Matrices.arikan_kernel()
        polar_matrix = kernel
        for _ in range(block_len_log - 1):
            polar_matrix = np.kron(polar_matrix, kernel)
        return polar_matrix.astype(np.uint8)

    @staticmethod
    def get_generator(frozen):
        """
        Create polar code generator matrix from the frozen bit pattern
        :param frozen: frozen bit pattern (1 -- frozen, 0 -- information)
        :return: polar code generator matrix
        """
        block_len = len(frozen)
        block_len_log = np.round(np.log2(block_len)).astype(np.int8)
        assert block_len == 2 ** block_len_log
        polar_matrix = Matrices.get_polar_transform(block_len_log)
        return polar_matrix[frozen == 0, :]

    @staticmethod
    def get_generator_systematic(frozen):
        """
        Create a polar code generator matrix in the systematic form
        :param frozen: frozen bit pattern (f == 0 -- information bit, f == 1 -- frozen bit)
        :return: Binary generator matrix, to multiply the information word (without CRC)
        """
        block_len = len(frozen)
        block_len_log = np.round(np.log2(block_len)).astype(np.int8)
        assert block_len == 2 ** block_len_log
        inf_bits_count = sum(frozen == 0)

        polar_transform = Matrices.get_polar_transform(block_len_log)
        # Select rows and columns of the polar transform matrix that correspond to frozen bits
        polar_transform_frozen = select(polar_transform, frozen == 1, frozen == 1)

        polar_generator = np.zeros((inf_bits_count, block_len))
        polar_generator[:, frozen == 0] = np.eye(inf_bits_count)
        polar_generator[:, frozen == 1] = np.dot(
            select(polar_transform, frozen == 0, frozen == 1),
            gf2_inverse(polar_transform_frozen)
        )
        return np.mod(polar_generator, 2)


def select(matr, row_mask, col_mask):
    """
    Tool function to select rows and columns from the matrix given row mask and column mask
    :param matr: matrix to pe processed
    :param row_mask: binary row mask, a vector of length equals to the row count of x
    :param col_mask: binary column mask, a vector of length equals to the column count of x
    :return: Sumbatrix with rows and columns selected in accordance with mask
    """
    return matr[np.ix_(row_mask, col_mask)]


def gf2_inverse(matr):
    """
    Inverse of the matrix over GF(2)
    :param matr: binary matrix to be processed
    :return: binary inverse matrix
    """
    return np.array(np.linalg.inv(galois.GF(2)(matr)))


def de2bi(decimal, dim):
    """
    Repeats the MATLAB de2bi output
    :param decimal: Integer vector
    :param dim: the number of columns in the output binary matrix
    :return: Binary matrix. Row count equals to the length of input vector,
    and number of columns equals to the output bit number
    """
    power = np.flipud(2 ** np.arange(dim - 1, -1, -1))
    dec_matrix = np.hstack([np.array(decimal).reshape(-1, 1)] * dim)
    return np.floor((dec_matrix % (2 * power)) / power)


# C++ implementation: compilation, linking, and execution routines
if os.name == 'nt':
    LIB_PATH = 'pcscl_lib.dll'
else:
    LIB_PATH = 'pcscl_lib.so'


def lib_compile():
    """
    Compile the C++ SCL decoder implementation
    :return:
    """
    wdir = os.path.dirname(__file__)
    if os.path.isfile(LIB_PATH):
        return
    src = ['pcscl_impl', 'pcscl_noperm_py']
    src_abs = [os.path.join(wdir, s) for s in src]
    if os.name == 'nt':
        if not os.popen('where g++').read():
            raise RuntimeError('g++ not found.')
    else:
        if not os.popen('which g++').read():
            raise RuntimeError('g++ not found.')
    for src_file in src_abs:
        os.system(f'g++ -fPIC -c -o {src_file}.o {src_file}.cpp')
    os.system(
        'g++ -shared -o ' +
        os.path.join(wdir, LIB_PATH) + ' ' +
        ''.join([s + '.o ' for s in src_abs])
    )
    obj_files = os.path.join(wdir, '*.o')
    if os.name == 'nt':
        os.system(f'del {obj_files}')
    else:
        os.system(f'rm {obj_files}')


def load_shared_object():
    """
    Load C++ implementation pf polar SCL decoder
    :return: ctypes.CDLL instance
    """
    wdir = os.path.dirname(__file__)
    if os.name == 'nt':
        if not os.popen('where g++').read():
           raise RuntimeError('g++ not found.')
        os.add_dll_directory(os.popen('where g++').read().replace('g++.exe\n',""))
    lib = ctypes.CDLL(os.path.join(wdir, LIB_PATH))
    # Return type:
    lib.decode.restype = None
    # Input arguments (the same as in pcscl_noperm_py.cpp):
    lib.decode.argtypes = [
        np.ctypeslib.ndpointer(dtype=np.double),
        np.ctypeslib.ndpointer(dtype=np.uint8),
        np.ctypeslib.ndpointer(dtype=np.uint8),
        np.ctypeslib.ndpointer(dtype=np.double),
        np.ctypeslib.ndpointer(dtype=np.double),
        ctypes.c_int,
        ctypes.c_int
    ]
    return lib


def decode(shared_lib, frozen_bit_pattern, llr_channel, list_size):
    """
    Run successive cancellation list decoder
    :param shared_lib: shared library (see load_shared_object)
    :param frozen_bit_pattern: frozen bit indicator (f==1 -- frozen, f == 0 -- information
    :param llr_channel: log likelihood rations from the channel (length n = 2 ** m)
    :param list_size: output list size
    :return: decoded bits (have shape L x n), sorted in accordance with path metrics
    """
    block_len = np.int32(len(llr_channel))
    block_len_log = np.int32(np.round(np.log2(block_len)))
    # Allocate memory for corresponding C types:
    llr_out = np.zeros(list_size * block_len, dtype=np.double)
    decoded_bits = np.zeros(list_size * block_len, dtype=np.uint8)
    path_metrics = np.zeros(list_size, dtype=np.double)
    # Run decoder
    shared_lib.decode(
        llr_channel.astype(np.double),
        frozen_bit_pattern.astype(np.uint8),
        decoded_bits,
        llr_out,
        path_metrics,
        np.int32(block_len_log),
        np.int32(list_size)
    )
    # Convert from 1-D array to 2-D array
    return np.reshape(decoded_bits, (-1, block_len))


# Single decoding demo:
def demo_run():
    """
    Polar decoder single run demo
    :return: None
    """
    np.random.seed(1)
    frozen_pattern = np.array([
        1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 0,
        1, 1, 1, 1, 1, 1, 0, 0,
        1, 1, 1, 0, 0, 0, 0, 0,
        1, 1, 1, 1, 1, 1, 0, 0,
        1, 0, 0, 0, 0, 0, 0, 0,
        1, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0
    ])
    crc_poly = np.array([1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1])  # CRC-11 from 3GPP

    lib_compile()

    polar = Polar(
        list_selection='CRC',
        crc_polynomial=crc_poly,
        frozen=frozen_pattern,
        use_systematic='True',
        list_size=2048,
    )
    iwd = np.random.randint(2, size=polar.information_bits(),)
    print('TX:', iwd)
    cwd = polar.encode(iwd)
    noise = np.random.normal(0, 1, (len(cwd),))
    llr = 1 - 2 * cwd.astype(np.double) + 1.2 * noise
    iwd_hat = polar.decode(llr, iwd=iwd)[0]
    print('RX:', iwd_hat)
    print('BER:', np.mean(iwd_hat != iwd))


if __name__ == '__main__':
    demo_run()
